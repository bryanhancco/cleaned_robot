considera el siguiente codigo
numberspy
import os
import cv2
import numpy as np
import tensorflow as tf
import time

# Obtener ruta absoluta al archivo del modelo
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
MODEL_PATH = os.path.join(BASE_DIR, 'mnist_cnn_model.keras')

# Cargar el modelo pre-entrenado
try:
    model = tf.keras.models.load_model(MODEL_PATH)
except Exception as e:
    print(f"Error al cargar el modelo desde {MODEL_PATH}: {e}")
    print("Asegúrate de haber entrenado y guardado el modelo correctamente.")
    model = None


_is_running = False


def run(stop_event=None):
    """Ejecuta el detector de números. Si se pasa stop_event (threading.Event), comprueba para terminar."""
    global _is_running
    if _is_running:
        print("El detector ya está en ejecución. Ignorando llamada duplicada.")
        return
    _is_running = True

    if model is None:
        print("Modelo no disponible. Abortando run().")
        return

    cap = cv2.VideoCapture(0)
    if not cap.isOpened():
        print("Error: No se pudo abrir la cámara.")
        return

    print("Presiona 'q' para salir (o enviar comando de salida desde la app).")

    lower_green_lemon = np.array([35, 100, 100])
    upper_green_lemon = np.array([85, 255, 255])

    try:
        while True:
            if stop_event is not None and stop_event.is_set():
                print("Stop event recibido. Saliendo de numbers.run().")
                break

            ret, frame = cap.read()
            if not ret:
                time.sleep(0.1)
                continue

            hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
            mask = cv2.inRange(hsv, lower_green_lemon, upper_green_lemon)

            kernel_m = np.ones((3, 3), np.uint8)
            mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel_m, iterations=1)
            mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel_m, iterations=1)

            contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

            plausible_contours = []
            for contour in contours:
                area = cv2.contourArea(contour)
                x, y, w, h = cv2.boundingRect(contour)
                if 1000 < area < 150000:
                    aspect_ratio = float(w) / h if h != 0 else 0
                    if 0.6 < aspect_ratio < 1.3:
                        plausible_contours.append((area, contour, (x, y, w, h)))

            if plausible_contours:
                plausible_contours.sort(key=lambda x: x[0], reverse=True)
                _, largest_contour, (x, y, w, h) = plausible_contours[0]
                cv2.rectangle(frame, (x, y), (x + w, y + h), (0, 255, 0), 2)
                roi = mask[y:y + h, x:x + w]

                if roi.size > 0 and np.max(roi) > 0:
                    target_size = 28
                    padding = 4
                    max_dim = max(roi.shape[0], roi.shape[1])
                    scale_factor = min((target_size - 2 * padding) / max_dim, 1.0)
                    resized_roi = cv2.resize(
                        roi,
                        (int(roi.shape[1] * scale_factor),
                         int(roi.shape[0] * scale_factor)),
                        interpolation=cv2.INTER_AREA
                    )

                    final_roi = np.zeros((target_size, target_size), dtype=np.uint8)
                    start_x = (target_size - resized_roi.shape[1]) // 2
                    start_y = (target_size - resized_roi.shape[0]) // 2
                    final_roi[start_y:start_y + resized_roi.shape[0],
                              start_x:start_x + resized_roi.shape[1]] = resized_roi
                    _, final_roi = cv2.threshold(final_roi, 127, 255, cv2.THRESH_BINARY)

                    inp = final_roi.astype('float32') / 255.0
                    inp = np.expand_dims(inp, axis=(0, -1))

                    preds = model.predict(inp, verbose=0)
                    digit = int(np.argmax(preds))
                    confidence = float(np.max(preds))

                    cv2.putText(
                        frame,
                        f"{digit} ({confidence * 100:.1f}%)",
                        (x, y - 10),
                        cv2.FONT_HERSHEY_SIMPLEX,
                        0.6,
                        (0, 255, 0),
                        2
                    )

            cv2.imshow('Mask', mask)
            cv2.imshow('Detector de Dígitos Verdes', frame)

            if cv2.waitKey(1) & 0xFF == ord('q'):
                print("Tecla 'q' pulsada. Saliendo del detector de números.")
                break

    finally:
        _is_running = False
        cap.release()
        time.sleep(0.2)
        cv2.destroyAllWindows()


if __name__ == '__main__':
    #run()
    print("Este módulo debe ser ejecutado desde main.py, no directamente.")

main.py
import threading
import importlib
from connection.connection_manager import check_device, setup_adb_forward, start_socket_connection
from typing import Optional

# Mapa de módulos disponibles -> (module, start_fn_name)
try:
    from features.number_recognition import numbers as numbers_mod
except Exception:
    numbers_mod = None

try:
    from features.figures_recognition import recognize_figures as figures_mod
except Exception:
    figures_mod = None

try:
    from features.color_recognition import color as color_mod
except Exception:
    color_mod = None


active_thread: Optional[threading.Thread] = None
active_stop_event: Optional[threading.Event] = None
active_name: Optional[str] = None


def start_module(name: str):
    global active_thread, active_stop_event, active_name
    if active_thread is not None and active_thread.is_alive():
        print(f"Ya hay un módulo activo: {active_name}. Deténlo antes de iniciar {name}.")
        return

    stop_ev = threading.Event()

    if name == 'n' and numbers_mod is not None:
        target = getattr(numbers_mod, 'run', None) or getattr(numbers_mod, 'main', None)
    elif name == 'fg' and figures_mod is not None:
        target = getattr(figures_mod, 'run', None) or getattr(figures_mod, 'iniciar_modo_ensenar', None) or getattr(figures_mod, 'main', None)
    elif name == 'c' and color_mod is not None:
        target = getattr(color_mod, 'run', None) or getattr(color_mod, 'main', None)
    else:
        print(f"Módulo '{name}' no disponible.")
        return

    if target is None:
        print(f"El módulo '{name}' no expone una función ejecutable compatible.")
        return

    def runner():
        try:
            # target puede aceptar o no el stop event; intentar pasarle
            try:
                target(stop_ev)
            except TypeError:
                # función sin parámetro: ejecutar directamente
                target()
        except Exception as e:
            print(f"Error en módulo {name}: {e}")

    th = threading.Thread(target=runner, daemon=True)
    active_thread = th
    active_stop_event = stop_ev
    active_name = name
    th.start()
    print(f"Módulo {name} iniciado.")


def stop_active_module(name: str):
    global active_thread, active_stop_event, active_name
    if active_thread is None or not active_thread.is_alive():
        print("No hay ningún módulo activo.")
        return
    if active_name != name:
        print(f"El módulo activo es {active_name}; para detenerlo envía '{active_name}_salida'.")
        return

    # Señalar parada
    if active_stop_event is not None:
        active_stop_event.set()
    active_thread.join(timeout=5)
    if active_thread.is_alive():
        print("El módulo no se detuvo dentro del tiempo esperado.")
    else:
        print(f"Módulo {name} detenido.")
    active_thread = None
    active_stop_event = None
    active_name = None


def handle_message(message: str):
    """Procesa los mensajes recibidos desde Flutter."""
    message = message.strip().lower()
    print(f"Comando recibido: {message}")

    if message == 'n_repaso':
        start_module('n')
    elif message == 'fg_repaso':
        start_module('fg')
    elif message == 'c_repaso':
        start_module('c')
    elif message == 'n_salida':
        stop_active_module('n')
    elif message == 'fg_salida':
        stop_active_module('fg')
    elif message == 'c_salida':
        stop_active_module('c')
    else:
        print(f"Comando desconocido: {message}")


def listen_socket(sock):
    """Escucha mensajes entrantes desde Flutter y los envia al manejador."""
    while True:
        try:
            data = sock.recv(1024)
            if not data:
                print("Conexión cerrada por Flutter.")
                break
            message = data.decode().strip()
            if message:
                handle_message(message)
        except Exception as e:
            print("Error en la recepción de datos:", e)
            break


def main():
    print("Iniciando aplicación educativa DigitalHub Perú...")

    if not check_device():
        print("Conecta un dispositivo Android con depuración USB activada y vuelve a intentar.")
        return

    setup_adb_forward()
    sock = start_socket_connection()

    print("Conexión establecida. Esperando comandos desde Flutter...")

    listen_socket(sock)

    sock.close()
    print("Aplicación finalizada.")


if __name__ == '__main__':
    main()

al ejecutarse sigue el flujo normal, la camara carga, se inicia el proceso relacionado con el comando n_repaso, pero durante su ejecucion se inicia una cantidad ilimitada de ventanas de cv2, como si el proceso de numbers.py se repitiera indefinidamente
